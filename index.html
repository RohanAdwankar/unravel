<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unravel</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000;
            --border-color: #e9ecef;
            --hover-color: #f1f3f5;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0; 
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        #app {
            width: 100%;
            max-width: 600px;
            padding: 2rem;
            flex: 1;
            box-sizing: border-box;
        }

        h1 {
            font-weight: 700;
            letter-spacing: -0.05em;
            margin-bottom: 2rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        input[type="text"] {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            border-color: var(--accent-color);
        }

        button {
            padding: 0.75rem 1.5rem;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 500;
            transition: opacity 0.2s;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            opacity: 0.8;
        }

        #status {
            font-size: 0.875rem;
            color: #6c757d;
            margin-bottom: 1rem;
            min-height: 1.5em;
        }

        /* Tree Styles */
        .tree-list {
            list-style: none;
            padding-left: 1.5rem;
            margin: 0;
            border-left: 1px solid var(--border-color);
        }

        #root-list {
            padding-left: 0;
            border-left: none;
            list-style: none;
        }

        .tree-item {
            margin: 0.5rem 0;
        }

        .item-content {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            position: relative;
            overflow: hidden; /* For the gradient overlay */
        }

        .item-content:hover {
            background-color: var(--hover-color);
        }

        /* Hot Potato Gradient Overlay */
        .hot-potato-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(255,0,0,0.1), rgba(255,0,0,0.4));
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease-in; 
        }

        .item-content.heating-up .hot-potato-overlay {
            opacity: 1;
        }

        .toggle-icon {
            margin-right: 0.5rem;
            width: 12px;
            height: 12px;
            transition: transform 0.2s;
            display: inline-block;
            fill: currentColor;
            opacity: 0.5;
            z-index: 1;
        }

        .expanded > .item-content > .toggle-icon {
            transform: rotate(90deg);
        }

        .item-text {
            font-weight: 500;
            z-index: 1;
        }

        .loading-dots::after {
            content: ' .';
            animation: dots 1.5s steps(5, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ' .'; }
            40% { content: ' ..'; }
            60% { content: ' ...'; }
            80%, 100% { content: ''; }
        }

        .hidden {
            display: none;
        }

        /* Footer */
        footer {
            width: 100%;
            background-color: #fff;
            border-top: 1px solid var(--border-color);
            padding: 1rem;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            margin-top: auto;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #ff4d4d; /* Red for hot potato */
        }

        input:checked + .slider:before {
            transform: translateX(16px);
        }

        .footer-label {
            font-weight: 500;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>unravel</h1>
        <div id="status">Initializing AI engine... (this may take a moment)</div>
        
        <div class="controls">
            <input type="text" id="seed-input" value="startup ideas" placeholder="Enter a topic to unravel...">
            <button id="start-btn" disabled>Start</button>
        </div>

        <div id="tree-container">
            <ul id="root-list"></ul>
        </div>
    </div>

    <footer>
        <span class="footer-label">Hot Potato Mode</span>
        <label class="switch">
            <input type="checkbox" id="hot-potato-toggle">
            <span class="slider"></span>
        </label>
    </footer>

    <script type="module">
        import * as webllm from "https://esm.run/@mlc-ai/web-llm";

        const statusEl = document.getElementById("status");
        const startBtn = document.getElementById("start-btn");
        const seedInput = document.getElementById("seed-input");
        const rootList = document.getElementById("root-list");
        const hotPotatoToggle = document.getElementById("hot-potato-toggle");

        let engine;
        const selectedModel = "Llama-3.2-1B-Instruct-q4f16_1-MLC";
        const chevronRight = `<svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>`;

        // State
        let isHotPotatoEnabled = false;
        let globalLoading = false; // To prevent concurrent expansions
        let mouseX = 0;
        let mouseY = 0;
        
        // Hot Potato State
        let currentHotTarget = null;
        let hotPotatoJobId = 0; 

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        hotPotatoToggle.addEventListener('change', (e) => {
            isHotPotatoEnabled = e.target.checked;
            if (!isHotPotatoEnabled) {
                cancelHotPotato();
            }
        });

        function cancelHotPotato() {
            if (currentHotTarget) {
                currentHotTarget.classList.remove('heating-up');
                currentHotTarget = null;
            }
            hotPotatoJobId++; // Increment job ID to invalidate pending jobs
        }

        // Loop to check proximity
        setInterval(() => {
            if (!isHotPotatoEnabled || globalLoading) return;
            
            // Find all valid candidates
            const candidates = Array.from(document.querySelectorAll('.item-content'));
            
            let closest = null;
            let minDist = Infinity;

            for (const el of candidates) {
                const li = el.parentElement;
                // Must be not expanded, visible
                if (!li || li.classList.contains('expanded') || el.offsetParent === null) {
                    continue;
                }

                const rect = el.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dist = Math.hypot(mouseX - centerX, mouseY - centerY);

                if (dist < minDist) {
                    minDist = dist;
                    closest = el;
                }
            }

            // Threshold for "closest"
            if (minDist > 500) closest = null;

            // If we found a closest item and it's different from current, switch
            if (closest && closest !== currentHotTarget) {
                // Cancel old
                cancelHotPotato();
                
                // Start new
                currentHotTarget = closest;
                startHotPotatoJob(closest);
            }
        }, 200); 

        async function startHotPotatoJob(targetEl) {
            // New job started
            const thisJobId = hotPotatoJobId;
            
            // Add visual class to trigger heating up animation
            targetEl.classList.add('heating-up');

            if (typeof targetEl.prepareExpansion === 'function') {
                targetEl.prepareExpansion(thisJobId).catch(console.error);
            }
        }


        async function initEngine() {
            try {
                startBtn.disabled = true;
                const createdEngine = await webllm.CreateMLCEngine(selectedModel, {
                    initProgressCallback: (p) => {
                        statusEl.innerText = p.text;
                    }
                });
                engine = createdEngine;
                statusEl.innerText = "Engine ready. Click start to unravel.";
                startBtn.disabled = false;
            } catch (err) {
                statusEl.innerText = "Error loading engine: " + err.message;
                console.error(err);
            }
        }

        async function fetchCategories(lineage) {
            const currentTopic = lineage[lineage.length - 1];
            const context = lineage.join(" > ");
            
            const prompt = `Generate a comma-separated list of 5 distinct, specific sub-categories or types of "${currentTopic}" that strictly belong within the ${context} hierarchy.
            Do not repeat the parent category name. Be precise and specific.
            Return ONLY the list separated by commas. Do not number them. Do not include any intro or outro text. Do not include the word and`;

            try {
                if (!engine) throw new Error("Engine not initialized");

                const response = await engine.chat.completions.create({
                    messages: [{ role: "user", content: prompt }],
                    temperature: 0.7,
                    max_tokens: 100,
                });
                
                const text = response.choices[0].message.content;
                const items = text.split(',')
                    .map(s => s.trim())
                    .filter(s => s.length > 0 && !s.toLowerCase().includes("here is a list"));
                return items.slice(0, 8);
            } catch (e) {
                console.error("Generation error", e);
                return ["Error generating items. Try again."];
            }
        }

        function createTreeItem(text, lineage) {
            const li = document.createElement("li");
            li.className = "tree-item";
            
            const content = document.createElement("div");
            content.className = "item-content";
            
            // Overlay for hot potato effect
            const overlay = document.createElement("div");
            overlay.className = "hot-potato-overlay";
            content.appendChild(overlay);
            
            const icon = document.createElement("span");
            icon.className = "toggle-icon";
            icon.innerHTML = chevronRight;
            
            const span = document.createElement("span");
            span.className = "item-text";
            span.innerText = text;

            content.appendChild(icon);
            content.appendChild(span);
            li.appendChild(content);

            const childrenUl = document.createElement("ul");
            childrenUl.className = "tree-list hidden";
            li.appendChild(childrenUl);

            let loaded = false;
            let loading = false;
            let expanded = false;

            const newLineage = [...lineage, text];

            const expand = async (isHotPotato = false, jobId = -1) => {
                // If manually clicked, ensure we cancel any ongoing hot potato job first
                if (!isHotPotato) {
                    cancelHotPotato();
                }

                if (loading) return;

                if (isHotPotato) {
                     // Start Fetching immediately but quietly
                     loading = true; 
                     
                     let categories = [];
                     try {
                         categories = await fetchCategories(newLineage);
                     } catch(e) {
                         categories = [];
                     }

                     // Check abandonment
                     if (jobId !== hotPotatoJobId) {
                         // Abandoned. Reset local loading state.
                         loading = false;
                         return; 
                     }
                     
                     // Not abandoned. Now strictly apply global loading to prevent conflicts
                     globalLoading = true;
                     finishExpansion(categories);

                } else {
                    // Normal Manual Click
                    expanded = !expanded;
                    if (expanded) {
                        li.classList.add("expanded");
                        childrenUl.classList.remove("hidden");

                        if (!loaded) {
                            loading = true;
                            globalLoading = true;
                            span.classList.add("loading-dots");
                            
                            const categories = await fetchCategories(newLineage);
                            finishExpansion(categories);
                        }
                    } else {
                        li.classList.remove("expanded");
                        childrenUl.classList.add("hidden");
                    }
                }
            };

            const finishExpansion = (categories) => {
                loading = false;
                loaded = true;
                globalLoading = false;
                expanded = true;
                
                span.classList.remove("loading-dots");
                
                li.classList.add("expanded");
                childrenUl.classList.remove("hidden");
                
                // Clear hot potato visuals instantly
                content.classList.remove('heating-up');
                
                // Also clear the global target reference if it matches this one
                if (currentHotTarget === content) {
                    currentHotTarget = null;
                }

                if (categories.length > 0) {
                    categories.forEach(cat => {
                        childrenUl.appendChild(createTreeItem(cat, newLineage));
                    });
                } else {
                        const empty = document.createElement("li");
                        empty.innerText = "(No sub-categories found)";
                        empty.style.paddingLeft = "2rem";
                        empty.style.color = "#999";
                        childrenUl.appendChild(empty);
                }
            };

            // Attach method to DOM element
            content.prepareExpansion = (jobId) => {
                return expand(true, jobId);
            };

            content.onclick = (e) => {
                e.stopPropagation();
                expand(false);
            };

            return li;
        }

        startBtn.onclick = async () => {
            if (!engine) return; 

            const topic = seedInput.value.trim();
            if (!topic) return;

            // Hide status when user starts
            statusEl.style.display = 'none';

            rootList.innerHTML = "";
            cancelHotPotato();
            
            startBtn.disabled = true;
            
            globalLoading = true;
            const initialLineage = [topic];
            const categories = await fetchCategories(initialLineage);
            globalLoading = false;
            
            categories.forEach(cat => {
                rootList.appendChild(createTreeItem(cat, initialLineage));
            });
            
            startBtn.disabled = false;
        };

        initEngine();

    </script>
</body>
</html>